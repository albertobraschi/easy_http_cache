Copyright (c) 2008 Jos√© Valim (jose.valim at gmail dot com)
Site: http://www.pagestacker.com/
Blog: http://josevalim.blogspot.com/
License: MIT
Version: 1.0

Description
-----------

Allows Rails applications to use HTTP 1.1 cache specifications easily:

  class ListsController < ApplicationController
    http_cache :index, :show
  end
  
Options:

  :last_change_at => Anything that responds_to :to_time. It accepts an Array and
                     Procs also (it runs through the array and process all Procs)

  :etag => Anything that responds_to :to_s and Procs

  :namespace => Anything that responds_to :to_s and Procs

  :if => Accepts Procs

  :unless => Accepts Procs

Install
-------

This plugin uses features that only exist on Rails 2.1 and above (including 2.1 RC)
So if you just want a static copy of the plugin:

    cd myapp
    git clone git://github.com/josevalim/easy-http-cache.git vendor/plugins/eash_http_cache
    rm -rf vendor/plugins/easy_http_cache/.git

Examples
--------

Just as above:

  class ListsController < ApplicationController
    http_cache :index, :show
  end

If you do not want to cache json requests, you can simply do:

  class ListsController < ApplicationController
    http_cache :index, :show, :if => Proc.new { |c| !c.request.format.json? }
  end

Another important example (perform cache only if flash is empty):

  class ListsController < ApplicationController
    http_cache :index, :show, :if => Proc.new { |c| c.flash.empty? }
  end

You can also set E-tag:

  class ListsController < ApplicationController
    http_cache :index, :show, :etag => 'this_will_never_change'
  end

Or use a Proc to set it:

  class ListsController < ApplicationController
    http_cache :index, :show, :etag => Proc.new {|c| c.get_instance_variable('@current_user').updated_at.to_f.to_s }
  end

All etags will be Digested with MD5, so if you want to use a string, feel free to
put something that matters to you. Another thing about E-tag is that Rails 2.1
automatically set them, but it only sets it after processing the whole action,
which is not the case here.

If you want to expire all http cache before 2008, just do:

  class ListsController < ApplicationController
    http_cache :index, :show, :last_change_at => Time.utc(2008)
  end

Or if you are looking into something more dynamic:

  class ListsController < ApplicationController
    http_cache :index, :show, :last_change_at => Proc.new{ 10.minutes.ago }
  end

How the last example works?
---------------------------

The first time http://www.railsapp.com/lists/index is requested, it renders the
action normally but adds a "Last-Modified" to your response with the current
request time, let's suppose 10h30.

If the client do another request at 10h35, the http_cache will check that
:last_change_at and see that the last change was at 10h25, which is older than
the "Last-Modified" field (10h30) returned by the client's browser, so it sends
a "304 Not Modified" response and does not execute the action.

But, if another request from the same client comes at 10h42, the last change was
at 10h32, which is newer than the "Last-Modified" field (10h30), so the action
is performed again and "Last-Modified" field set at 10h42.

Namespaces
----------

Do you have a page that is different for each user, but has the same url. How
would you guarantee that they won't see each other page if they are on the same
computer? Just do:

  class ListsController < ApplicationController
    http_cache :index, :show, :last_change_at => Time.utc(2008), :namespace => Proc.new{|c| c.get_instance_variable('@current_user').username}
  end

If the namespace is 'josevalim', the header will be:

  headers['Cache-Control'] = 'private=josevalim, max-age=0, must-revalidate'

The namespace is downcased and any character that doesn't belongs to [a-z] range
is removed (including spaces).

More examples
-------------
 
You can also pass an array at :last_change_at as below:

  class ListsController < ApplicationController
    http_cache :index, :show, :last_change_at => [ Time.utc(2007,12,27), Proc.new { 10.minutes.ago } ]
  end

This will check which one is the newest time to compare with the "Last-Modified" field sent by the client.
 
Nonetheless, you can use the Proc to be called within the current controller instance also:

  class ListsController < ApplicationController
    http_cache :index, :show, :last_change_at => [ Proc.new {|c| c.get_instance_variable('@current_user').updated_at, Time.utc(2007,12,27), 10.minutes.ago ]
  end

To avoid errors when @current_user is not defined in the controller, you can do:

  class ListsController < ApplicationController
    http_cache :index, :show, :last_change_at => Proc.new {|c| c.get_instance_variable('@current_user'), :if => Proc.new{|c| c.get_instance_variable('@current_user') }
  end

Or a shortcut:

  class ListsController < ApplicationController
    http_cache :index, :show, :last_change_at => Proc.new {|c| user = c.get_instance_variable('@current_user') ? user.updated_at : false }
  end

If :last_change_at contains any object that doesn't responds to :to_time the
cache is not performed.

Finally, if any Proc or Method with arity > 0 is not found in any key (:etag,
:last_change_at, :if, :unless) the http_cache filter will be prepend to your
filter chain. This behavior is desired when rendering static pages.
